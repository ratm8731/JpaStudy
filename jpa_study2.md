# 2주차

## 엔티티 매핑

### 객체와 테이블 매핑 
  - @Entity
    - Jpa가 관리하는 엔티티
    - 기본 생성자 필수
    - final 클래스, enum, interface, inner 클래스 사용 X
    - 저장할 필드에 final 사용 X
  - @Table
    - 매핑할 테이블 이름
  - 데이터 베이스 스키마 자동 생성
    - DDL을 애플리케이션 실행 시점에 자동 생성
    - 데이터베이스 방언을 활용하여 데이터베이스에 맞는 적절한 DDL 생성
    - hibernate.hbm2ddl.auto(방언에 따라 쿼리가 틀려짐)
      - create
        - 기존 테이블 삭제 후 재생성
      - create-drop
        - 기존 테이블 삭제 후 재생성 어플리케이션 완료 시 테이블 삭제
      - update
        - 변경분만 반영
        - 컬럼 삭제에 대해서는 반영되지 않음
      - validate
        - 엔티티와 테이블 매핑 확인
      - non
        - 사용하지 않음
      - 운용장비에 사용은 권장하지 않음(왠만하면 스크립트로 수동)
  - 필드와 컬럼 매핑 : @Column, @Enumerated, @Temporal, @Lob
    - @Transient : 매핑을 안할때 사용
    - 나머지 속성에 대해서는 필요에 따라 옵션 설정하면 다양한 기능 가능
  - 기본키 매핑
    - @Id
    - @GeneratedValue
      - 자동 생성
        - IDENTITY : 데이터베이스에 위임
          - 데이터 베이스에 인서트 후 아이디값을 알 수 있다
          - 커밋 전에 인서트 쿼리 실행 후 아이디값을 가져옴
          - 성능에 단점을 확인하기에는 힘듬
        - SEQUENCE : 데이터베이스 시퀀스 사용
          - allocationSize 한번 생성에 미리 갯수만큼 생성
          - maria DB 10.3부터 지원
        - TABLE : 키 생성용 테이블 사용(모든 데이터베이스 가능하나 성능에 문제)
        - AUTO : 방언에 따라 자동 지정(기본값)
  - 연관 관계 매핑 : @ManyToOne, @JoinColumn
    - 단방향 연관 관계
      - 단방향 매핑만으로도 이미 연관 관계 매핑은 완료
  - 양방향 연관 관계
      - 연관 관계의 주인
        - 객체에서 양방향 연관 관계는 서로 다른 단방향 관계가 2개라고 생각
        - 테이블에서 양방향 연관 관계는 외래키 하나로 두 테이블의 연관 관계를 가짐
        - 객체에서는 두개의 관계에서 어느 하나는 외래키를 관리해야 함(주인)
        - 주인은 mappedBy 속성 사용 X
        - 외래키가 있는 곳을 주인으로 지정(추천)
        - N(주인) : 1 기준을 주면 좋음
      - mappedBy 
        - @OneToOne, @OneToMany, @ManyToMany 어노테이션에서 사용
        - mappedBy가 없으면 JAP에서 양뱡향 관계라는 것을 모르고 두 엔티티의 매핑 테이블을 생성
      - 주의점
        - 업데이트 시 주인의 객체에 값을 입력
        - flush 없는 상태에서 객체 정보를 가져오는 상황에서는 값이 없기때문에 양쪽에 셋팅
        - 연관 관계 편의 메소드를 생성해서 관리하는걸 권장
      - 단방향 매핑 설계를 잘 하고 양방향은 필요할 때 추가
      - 다대일 : @ManyToOne
        - N(외래키) : 1 N이 연관 관계의 주인
        - 양쪽을 참조하도록 개발
      - 일대다 : @OneToMany
        - 단방향 일 경우 1(연관 관계의 주인) : N(외래키)
          - 객체와 테이블 차이로 발생하는 구조
          - 연관 관계 관리를 위한 UPDATE 쿼리 실행
          - @JoinColumn 미사용시 중간 테이블이 생성됨
          - 일대다 단방향 보단 다대일 양방향 매핑 사용하는게 더 나음
        - @JoinColumn(insertable=false, updatable=false) 읽기 전용 필드를 사용해서 양방향처럼 사용
      - 일대일 : @OneToOne
        - 주 데이블이나 대상 테이블 중에 외래키 선택 가능
          - 주 테이블에 외래키
            - 단방향은 다대일(@ManyToOne) 단방향 매핑과 유사
            - 양방향은 외래키가 있는 곳이 연관 관계의 주인 반대편은 mappedBy 사용
            - 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
          - 대상 테이블에 외래키
            - 단방향은 불가능
            - 양방향 일대일 주 테이블에 외래 키 양방향과 매핑 방법은 같음
            - 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
            - 항상 즉시 로딩 됨(프록시는 뒤에 설명)
        - 외래키에 데이터베이스 유니크 제약 조건 추가
      - 다대다 : @ManyToMany
        - 관계형 데이터베이스는 다대다 관계를 표현 못함
        - 연결 테이블을 추가해서 일대다, 다대일 관계로 우회해서 구현
        - 객체의 기능을 억지로 JPA가 만들어준 느낌으로 사용 권장하지 않음
        - @ManyToMany -> 중간 테이블 생성 후 @OneToMany, @ManyToOne으로 설계 가능
  - 상속관계 매핑
    - 조인 전략
      - @Inheritance(strategy = InheritanceType.JOINED)
      - 장점
        - 테이블 정규화
        - 외래 키 참조 무결성 제약조건 활용가능
        - 저장 공간 효율화
      - 단점
        - 조회시 조인을 많이 사용
        - 조회 쿼리가 복잡
        - 데이터 저장시 여러번 INSERT
    - 단일 테이블 전략(디폴트)
      - @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
      - 장점
        - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
        - 조회 쿼리가 단순함
      - 단점
        - 자식 엔티티가 매핑한 컬럼은 모두 null 허용
        - 테이블이 거대화 될 수 있으며 추후 성능 저하 가능성도 있음
    - 각 클래스마다 테이블 생성 전략
      - @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
      - @DiscriminatorColumn 불가
      - 데이터베이스 설계자와 ORM 전문가 둘 다 추천X
      - 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION 쿼리 실행)
  - MappedSuperclass
    - 공통 매핑 정보가 필요할 때 사용
    - 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할
    - ASM에도 사용하는게 있음(MalwareAgentLogRelation)
    - 조회, 검색 불가
    - 추상 클래스 권장
